Ниже — **пример** (концептуальный, но достаточно конкретный) **разбора** мини-конфигурации «Мини Заказы» из **XML-файлов**, где у нас есть:

1. **Справочники**: «Контрагенты», «Номенклатура»  
2. **Документ**: «ЗаказПокупателя» (с табличной частью «Товары»)  
3. **Регистр накопления**: «ЗаказыПоКонтрагентам»  

и в модуле документа — методы `ПриЗаписи`, `ПриПроведении`, где рассчитываются суммы и формируются движения.

### Что имеем?

После выгрузки конфигурации 1С (например, `v8unpack`, `bsl-loader`, `Designer` -> «Выгрузить…»), в папке будут **XML-файлы**, в том числе:

- `Documents\ЗаказПокупателя\ObjectModule.xml` (или что-то вроде `Document_ЗаказПокупателя\ObjectModule.xml`) — код модуля объекта  
- `Documents\ЗаказПокупателя\ManagerModule.xml` — код модуля менеджера (может быть пуст)  
- `Documents\ЗаказПокупателя\Description.xml` — описание метаданных (реквизиты, табличные части и т.д.)  
- `Catalogs\Контрагенты\Description.xml` — описание справочника «Контрагенты»  
- `Catalogs\Номенклатура\Description.xml` — описание справочника «Номенклатура»  
- `AccumulationRegisters\ЗаказыПоКонтрагентам\Description.xml` — описание регистра  
- …и так далее.

Ниже показан **упрощённый** пример, **как** внутри этих XML могут выглядеть фрагменты. Мы **не** гарантируем, что это **точный** формат выгрузки 1С, но **похоже** на то, что реально встретите.

---

## 1. Пример XML для «Документ.ЗаказПокупателя\Description.xml»

```xml
<MetaDataObject type="Document" name="ЗаказПокупателя" uuid="{C47E...}">
    <Name>ЗаказПокупателя</Name>
    <Properties>
        <Property>
            <Name>Контрагент</Name>
            <Type>CatalogRef.Контрагенты</Type>
        </Property>
        <Property>
            <Name>СуммаДокумента</Name>
            <Type>Number</Type>
            <NumberQualifiers>
                <Precision>15</Precision>
                <Scale>2</Scale>
            </NumberQualifiers>
        </Property>
        <Property>
            <Name>Дата</Name>
            <Type>DateTime</Type>
        </Property>
        <Property>
            <Name>Номер</Name>
            <Type>String</Type>
        </Property>
    </Properties>

    <TabularSections>
        <TabularSection>
            <Name>Товары</Name>
            <Fields>
                <Field>
                    <Name>Номенклатура</Name>
                    <Type>CatalogRef.Номенклатура</Type>
                </Field>
                <Field>
                    <Name>Количество</Name>
                    <Type>Number</Type>
                </Field>
                <Field>
                    <Name>Цена</Name>
                    <Type>Number</Type>
                </Field>
                <Field>
                    <Name>СуммаСтроки</Name>
                    <Type>Number</Type>
                </Field>
            </Fields>
        </TabularSection>
    </TabularSections>

    <!-- Дополнительные сведения, формы и т.д. -->
</MetaDataObject>
```

**Как парсим?**  
- Мы видим `type="Document"` и `<Name>ЗаказПокупателя</Name>` — значит это **Документ** «ЗаказПокупателя».  
- Реквизиты (Properties): «Контрагент» (CatalogRef.Контрагенты), «СуммаДокумента» (Number), «Дата» (DateTime), «Номер» (String).  
- Табличная часть: «Товары», где есть поля «Номенклатура», «Количество», «Цена», «СуммаСтроки».  

**Результат парсинга** (в виде структуры) может выглядеть примерно так (псевдо-JSON/псевдокод):

```jsonc
{
  "type": "Document",
  "name": "ЗаказПокупателя",
  "uuid": "{C47E...}",
  "properties": [
    { "name": "Контрагент", "type": "CatalogRef.Контрагенты" },
    { "name": "СуммаДокумента", "type": "Number", "precision": 15, "scale": 2 },
    { "name": "Дата", "type": "DateTime" },
    { "name": "Номер", "type": "String" }
  ],
  "tabularSections": [
    {
      "name": "Товары",
      "fields": [
        { "name": "Номенклатура", "type": "CatalogRef.Номенклатура" },
        { "name": "Количество", "type": "Number" },
        { "name": "Цена", "type": "Number" },
        { "name": "СуммаСтроки", "type": "Number" }
      ]
    }
  ]
}
```

---

## 2. Модуль объекта «ЗаказПокупателя» (ObjectModule.xml)

Предположим, в файле есть фрагмент:

```xml
<ObjectModule>
    <![CDATA[
    Процедура ПриЗаписи(Отказ, РежимЗаписи)
        Сумма = 0;
        Для Каждого СтрокаТЧ Из Товары Цикл
            СтрокаТЧ.СуммаСтроки = СтрокаТЧ.Количество * СтрокаТЧ.Цена;
            Сумма = Сумма + СтрокаТЧ.СуммаСтроки;
        КонецЦикла;

        СуммаДокумента = Сумма;
    КонецПроцедуры;

    Процедура ПриПроведении(Отказ, РежимПроведения)
        Движения.ЗаказыПоКонтрагентам.Очистить();
        НоваяСтрока = Движения.ЗаказыПоКонтрагентам.Добавить();
        НоваяСтрока.Контрагент = Контрагент;
        НоваяСтрока.СуммаЗаказов = СуммаДокумента;
    КонецПроцедуры;
    ]]>
</ObjectModule>
```

**Как обрабатываем?**

1. Ищем в XML узел `<ObjectModule>` и извлекаем содержимое `<![CDATA[ ... ]]>`.  
2. Сохраняем в отдельную строку (например, `String moduleText`).  
3. Далее — запускаем лексер/парсер 1С (BSL Parser и т.п.) для получения **AST**.  

Пример (упрощённый) **AST** для «ПриЗаписи» мы уже показывали раньше. В итоге у нас структура:

```jsonc
{
  "moduleType": "ObjectModule",
  "procedures": [
    {
      "name": "ПриЗаписи",
      "params": ["Отказ", "РежимЗаписи"],
      "body": [
        // операторы (присвоения, циклы)
      ]
    },
    {
      "name": "ПриПроведении",
      "params": ["Отказ", "РежимПроведения"],
      "body": [
        // операторы (Очистить(), Добавить(), присвоения "НоваяСтрока.Контрагент = Контрагент", etc.)
      ]
    }
  ]
}
```

---

## 3. Справочник «Контрагенты» (Catalogs\Контрагенты\Description.xml)

```xml
<MetaDataObject type="Catalog" name="Контрагенты" uuid="{A12B...}">
    <Name>Контрагенты</Name>
    <Properties>
        <Property>
            <Name>Наименование</Name>
            <Type>String</Type>
        </Property>
        <Property>
            <Name>ИНН</Name>
            <Type>String</Type>
        </Property>
    </Properties>
    <!-- Возможно, формы, модули и т.д. -->
</MetaDataObject>
```

Парсим аналогично:

```jsonc
{
  "type": "Catalog",
  "name": "Контрагенты",
  "uuid": "{A12B...}",
  "properties": [
    { "name": "Наименование", "type": "String" },
    { "name": "ИНН", "type": "String" }
  ]
}
```

---

## 4. Регистр накопления «ЗаказыПоКонтрагентам»

Представим `AccumulationRegisters\ЗаказыПоКонтрагентам\Description.xml`:

```xml
<MetaDataObject type="AccumulationRegister" name="ЗаказыПоКонтрагентам" uuid="{D44A...}">
    <Name>ЗаказыПоКонтрагентам</Name>
    <Dimensions>
        <Dimension>
            <Name>Контрагент</Name>
            <Type>CatalogRef.Контрагенты</Type>
        </Dimension>
    </Dimensions>
    <Resources>
        <Resource>
            <Name>СуммаЗаказов</Name>
            <Type>Number</Type>
        </Resource>
    </Resources>
</MetaDataObject>
```

Результат разбора:

```jsonc
{
  "type": "AccumulationRegister",
  "name": "ЗаказыПоКонтрагентам",
  "uuid": "{D44A...}",
  "dimensions": [
    { "name": "Контрагент", "type": "CatalogRef.Контрагенты" }
  ],
  "resources": [
    { "name": "СуммаЗаказов", "type": "Number" }
  ]
}
```

---

## 5. Сборка «Архитектурного» уровня (п.7)

На основе всех полученных структур мы можем **автоматически** построить дерево (или список) объектов:

```
└─ Catalogs
   └─ "Контрагенты" 
        - Реквизиты: Наименование (String), ИНН (String)
└─ Catalogs
   └─ "Номенклатура" 
        - Реквизиты: Наименование (String), ЕдиницаИзмерения (String)
└─ Documents
   └─ "ЗаказПокупателя"
        - Реквизиты: Контрагент (CatalogRef.Контрагенты), СуммаДокумента(Число), Дата, Номер
        - Табличная часть "Товары": Номенклатура, Количество, Цена, СуммаСтроки
        - Модули: Объект (ПриЗаписи, ПриПроведении), Менеджер (возможно пуст)
└─ AccumulationRegisters
   └─ "ЗаказыПоКонтрагентам"
        - Измерения: Контрагент (CatalogRef.Контрагенты)
        - Ресурсы: СуммаЗаказов (Number)
```

Это и есть **архитектурное** представление конфигурации: список **типов** (Справочник, Документ, Регистр), их реквизиты и связи (CatalogRef).

---

## 6. «Domain Model» (п.8) (упрощённо и автоматически)

Без ручного «переименования» на бизнес-термины (вроде «Order», «Client», «Product»), но всё равно можем **автоматически** зафиксировать:

```jsonc
{
  "documents": [
    {
      "name": "ЗаказПокупателя",
      "fields": [
        {"name":"Контрагент","type":"CatalogRef.Контрагенты"},
        {"name":"СуммаДокумента","type":"Number"},
        {"name":"Дата","type":"DateTime"},
        {"name":"Номер","type":"String"}
      ],
      "tableParts": [
        {
          "name":"Товары",
          "fields":[
            {"name":"Номенклатура","type":"CatalogRef.Номенклатура"},
            {"name":"Количество","type":"Number"},
            {"name":"Цена","type":"Number"},
            {"name":"СуммаСтроки","type":"Number"}
          ]
        }
      ]
    }
  ],
  "catalogs": [
    {
      "name":"Контрагенты",
      "fields":[
        {"name":"Наименование","type":"String"},
        {"name":"ИНН","type":"String"}
      ]
    },
    {
      "name":"Номенклатура",
      "fields":[
        {"name":"Наименование","type":"String"},
        {"name":"ЕдиницаИзмерения","type":"String"}
      ]
    }
  ],
  "accRegisters": [
    {
      "name":"ЗаказыПоКонтрагентам",
      "dimensions":[
        {"name":"Контрагент","type":"CatalogRef.Контрагенты"}
      ],
      "resources":[
        {"name":"СуммаЗаказов","type":"Number"}
      ]
    }
  ]
}
```

---

## 7. Код модулей (AST, п.4) и Code Model (п.5)

### 7.1. AST для процедуры «ПриЗаписи»

Уже видели нечто похожее. Получим (упрощённо):

```jsonc
{
  "type": "Procedure",
  "name": "ПриЗаписи",
  "params": ["Отказ", "РежимЗаписи"],
  "body": [
    {
      "type": "Assignment",
      "target": "Сумма",
      "expression": {"type":"NumericLiteral","value":0}
    },
    {
      "type":"ForEach",
      "iterator":"СтрокаТЧ",
      "collection":"Товары",
      "body":[
        {
          "type":"Assignment",
          "target":"СтрокаТЧ.СуммаСтроки",
          "expression":{
            "type":"BinaryOp","operator":"*",
            "left":"СтрокаТЧ.Количество","right":"СтрокаТЧ.Цена"
          }
        },
        {
          "type":"Assignment",
          "target":"Сумма",
          "expression":{
            "type":"BinaryOp","operator":"+",
            "left":"Сумма","right":"СтрокаТЧ.СуммаСтроки"
          }
        }
      ]
    },
    {
      "type":"Assignment",
      "target":"СуммаДокумента",
      "expression":"Сумма"
    }
  ]
}
```

### 7.2. Code Model / IR

На уровне **Code Model** мы можем сказать:

```jsonc
{
  "objectName": "Документ.ЗаказПокупателя",
  "moduleType": "ObjectModule",
  "procedures": [
    {
      "name": "ПриЗаписи",
      "params": ["Отказ","РежимЗаписи"],
      "statements": [
         // ... (ForEach, Assignments) ...
      ]
    },
    {
      "name": "ПриПроведении",
      "params": ["Отказ","РежимПроведения"],
      "statements": [
         // Очистить, Добавить, "НоваяСтрока.Контрагент = Контрагент" и т.д.
      ]
    }
  ]
}
```

А затем связать это с информацией о табличной части «Товары» и регистре «ЗаказыПоКонтрагентам» (Dependency Graph). 

---

## 8. Применение

- **Если** мы хотим **сгенерировать** (Go + JS), мы берём полученную структуру (пп. 5–7):
  1. Из **документа** «ЗаказПокупателя» создаём структуру `Order` (Go) с полями (clientID, totalAmount, date, number) + список `OrderItems`.  
  2. Из **AST** для «ПриЗаписи» генерируем функцию `Recalculate()` (пример выше).  
  3. Из **ПриПроведении** генерируем метод `Confirm()` или что-то похожее, который пишет данные в «ЗаказыПоКонтрагентам».  

- **Если** мы хотим просто **восстановить** описание конфигурации (Reverse Engineering/документацию), всё это можно отобразить в виде диаграмм, табличных описаний и т.д.

---

# Короткий итог

Таким образом, **полный** «пример разбора» мини-конфигурации «Мини Заказы» из **XML** состоит из:

1. **Чтения** `Description.xml` для каждого объекта (Справочник, Документ, Регистр) — извлекаем метаданные о реквизитах, табличных частях, типах.  
2. **Чтения** модулей (`<ObjectModule>`, `<ManagerModule>`, `<FormModule>`…) из `<![CDATA[ ... ]]>` — получаем **сырой код**.  
3. **Парсинга** кода → **AST**.  
4. **Построения** (5) Code Model (связь AST с объектом) и **(7) Архитектурного слоя**, а также *автоматической* «(8) Доменной модели» (пусть и с «сырыми» русскими названиями).  

В результате мы получаем **структурированное** описание (реквизиты, формы, связи), **деревья** процедур, и можем **далее** либо генерировать что-то (Go/JS), либо визуализировать, либо анализировать зависимости. Всё это — **без** ручных дополнительных «мини-примеров» и «описаний», только по XML и исходному коду из CDATA.









******************************************
Ниже кратко **раскрываю** идею о том, что значит **«связать это с информацией о табличной части «Товары» и регистре «ЗаказыПоКонтрагентам» (Dependency Graph)»**.

---

## 1. Что за «Dependency Graph»?

- **Dependency Graph** (уровень 6, когда мы говорим о всех наших абстракциях) — это **граф зависимостей** между объектами конфигурации: кто из модуля кого вызывает, какие объекты (документы, справочники, регистры) ссылаются друг на друга, кто читает/записывает какие поля и т.д.  
- Иными словами, это сеть (graph), где **вершины** — объекты (например, «Документ.ЗаказПокупателя», «Регистр.ЗаказыПоКонтрагентам», «Справочник.Контрагенты») или модули («Модуль объекта документа», «Модуль формы»), а **рёбра** — типы обращения или ссылки (вызов метода, ссылка на реквизит, движение по регистру и пр.).

## 2. Где здесь табличная часть «Товары» и регистр «ЗаказыПоКонтрагентам»?

- В коде процедуры «ПриЗаписи» упоминается табличная часть **«Товары»** (цикл `Для Каждого СтрокаТЧ Из Товары`).  
  - Значит, **модуль** («ЗаказПокупателя.Объект») **зависит** (или «обращается») к конкретной **табличной части** **«Товары»**.  
- В коде «ПриПроведении» упоминается `Движения.ЗаказыПоКонтрагентам`.  
  - Это означает, что тот же **модуль** («ЗаказПокупателя.Объект») обращается к **регистру** **«ЗаказыПоКонтрагентам»** (очищает, добавляет движение).

## 3. Как это выглядит на уровне «графа»?

1. **Узел**: Модуль «Документ.ЗаказПокупателя (Объект)»  
2. **Узел**: Табличная часть «Товары» (или можно считать её частью одного узла «Документ ЗаказПокупателя», смотря как мы строим модель)  
3. **Узел**: Регистр «ЗаказыПоКонтрагентам»  

Соответственно, в **графе** будет:  
- **Ребро** из модуля «Документ.ЗаказПокупателя (Объект)» к **ТЧ «Товары»** (тип «Чтение/изменение»), так как код перебирает строки `Товары` и пишет в поле `СуммаСтроки`.  
- **Ребро** из модуля «Документ.ЗаказПокупателя (Объект)» к **Регистр «ЗаказыПоКонтрагентам»** (тип «Запись движения»), так как код «ПриПроведении» очищает/добавляет запись в регистр.

## 4. Зачем «связывать» с табличной частью и регистром?

- Когда мы **просто** смотрим на AST, мы видим:  
  ```
  ForEach СтрокаТЧ из "Товары"
     СтрокаТЧ.СуммаСтроки = ...
  ...
  Движения.ЗаказыПоКонтрагентам.Очистить();
  Движения.ЗаказыПоКонтрагентам.Добавить();
  ```  
  Но **AST** знает лишь: «есть некий идентификатор “Товары”, некая сущность “Движения.ЗаказыПоКонтрагентам”», а не полностью контекст, что «Товары» = табличная часть, «ЗаказыПоКонтрагентам» = регистр.
- Чтобы **понимать**, что это за «Товары» и что за «ЗаказыПоКонтрагентам», мы **обращаемся к описанию** метаданных (7-й уровень архитектуры). Там сказано:
  - «Документ.ЗаказПокупателя» имеет ТЧ «Товары».  
  - «РегистрНакопления.ЗаказыПоКонтрагентам» существует с такими-то измерениями/ресурсами.  
- **Связывая** код (AST) с архитектурной информацией, мы можем более точно построить **«граф зависимостей»**, где отражены **конкретные объекты** 1С, а не просто «строка “Товары”».

## 5. Итог: что значит «связать с ТЧ «Товары» и регистром «ЗаказыПоКонтрагентам»»?

- Это значит **зафиксировать** в нашей аналитической модели (Dependency Graph / Cross-Reference), что **код модуля** документа «ЗаказПокупателя» при выполнении «ПриЗаписи» **читает/изменяет** данные табличной части «Товары», а при выполнении «ПриПроведении» **формирует движения** по «ЗаказыПоКонтрагентам».  
- Благодаря этому, когда мы будем смотреть, **где** используется регистр или как связана табличная часть, мы **увидим** в графе:  
  > «Регистр “ЗаказыПоКонтрагентам” вызывается (используется) в модуле объекта “ЗаказПокупателя” при процедуре “ПриПроведении”».  
  > «Табличная часть “Товары” читается и записывается в модуле объекта “ЗаказПокупателя” при “ПриЗаписи”».  

Таким образом, **«связать»** = **«привязать узлы к соответствующим объектам»** и **«указать тип взаимосвязи (вызов, чтение, запись, движение)»**, чтобы в итоговой **сети зависимостей** чётко отобразить, **какие** объекты конфигурации 1С «задействованы» при выполнении кода модуля.