Ниже — пример **технического задания** (ТЗ) на разработку **мини-веб-приложения** (HTML, JavaScript, Go), которое реализует простой **учёт заказов**. В результате должна получиться небольшая система, где можно **вносить** клиентов (контрагентов), товары, оформлять заказы с несколькими позициями (товарами), автоматически считать суммы и **фиксировать** результат в неком «реестре» (регистре) сумм заказов по каждому клиенту.

> **Важный момент**: это задание **полностью независимо** от 1С или любой другой платформы. Мы описываем **предметную область** и **бизнес-логику** в общих терминах, а вам нужно реализовать это в **стеке HTML + JavaScript (frontend)** и **Go (backend)** с базой данных (например, PostgreSQL).

---

# 1. Цель и общее описание системы

Система должна решать следующую задачу:

- **Управлять** справочниками **клиентов** и **товаров**.  
- **Позволять** оформлять **заказы** от клиентов, в каждом заказе указывать несколько позиций (товар, количество, цена).  
- **Автоматически** рассчитывать итоговую сумму заказа.  
- **Фиксировать** (подтверждать) заказ, записывая итоговую сумму в специальную таблицу («регистр/реестр») для агрегации сумм заказов по клиентам.

Эта система будет «учебным полигоном», где мы хотим продемонстрировать базовые операции **CRUD** (Create, Read, Update, Delete) + **расчёт суммы** в заказе, + **актуализацию** агрегированных данных (суммы по клиентам).

---

# 2. Ключевые сущности (Domain Model)

1. **Client** (клиент / контрагент)  
   - Поля:  
     - `id` (уникальный идентификатор)  
     - `name` (строка, название клиента)  
     - `inn` (опционально, можно оставить пустым — идентификационный номер)

2. **Product** (товар / номенклатура)  
   - Поля:  
     - `id`  
     - `name` (строка, наименование)  
     - `unit` (строка, единица измерения, например, «шт»)

3. **Order** (заказ)  
   - Поля (шапка заказа):  
     - `id`  
     - `client_id` (ссылка на `Client`)  
     - `date` (дата/время создания)  
     - `number` (строка или числовой код — уникальный в рамках заказов)  
     - `total_amount` (число, сумма всего заказа)  
   - **OrderItem** (позиция заказа, табличная часть):  
     - `id`  
     - `order_id` (ссылка на `Order`)  
     - `product_id` (ссылка на `Product`)  
     - `quantity` (число)  
     - `price` (число)  
     - `line_amount` (число, «сумма строки», рассчитывается как quantity * price)

4. **OrdersByClient** (регистр / агрегированная таблица)  
   - Поля:  
     - `client_id` (уникально в рамках записи)  
     - `orders_sum` (число, суммарная сумма всех подтверждённых заказов по клиенту)

---

# 3. Функциональные требования

## 3.1. Управление справочниками (Clients, Products)

- **Создание** клиента (client)  
  - Поля: `name`, `inn` (необязательно уникальный).  
- **Чтение** списка клиентов (через веб-интерфейс и/или API).  
- **Редактирование** данных клиента.  
- **Удаление** клиента (если не связано с заказами, либо разрешить удалять и cascading?).  

Аналогичные операции **CRUD** для товаров (products).

## 3.2. Работа с заказами (Orders + OrderItems)

1. **Создание** нового заказа  
   - Указывается: `client_id`, `date`, `number` (при желании можно генерировать автоматически).  
   - При создании должно быть возможно **добавлять** одну или несколько позиций (OrderItems).  
     - Для каждой позиции: `product_id`, `quantity`, `price`.  
     - `line_amount` = `quantity * price`, **должен рассчитываться автоматически** (на сервере при сохранении, либо на клиенте + проверка/пересчёт на бэкенде).

2. **Подсчёт** общей суммы заказа  
   - `total_amount` = сумма всех `line_amount` позиций.  
   - Происходит автоматически при **сохранении** (или при обновлении) заказа.

3. **Подтверждение** (проведение) заказа  
   - С точки зрения бизнеса, это означает «заказ зафиксирован, добавить сумму заказа к агрегированным суммам клиента».  
   - При подтверждении (или «проведении») нужно:  
     - Найти запись в `OrdersByClient` по `client_id`.  
     - Прибавить `total_amount` к полю `orders_sum`. Если записи нет, создать её.  
   - Допускается, что «подтверждённый» заказ не редактируется (или, если редактируется, то нужна коррекция сумм в `OrdersByClient` — на ваше усмотрение).

4. **Просмотр** списка заказов  
   - Показать `id`, `number`, `date`, `client.name`, `total_amount`, статус (подтверждён / нет).  
5. **Редактирование** заказа (до подтверждения)  
   - Возможность менять позиции, recalculating `total_amount`.  
6. **Удаление** заказа  
   - Если заказ уже подтверждён, нужно решить, можно ли удалять (и тогда корректировать `OrdersByClient`) или запрещать.

---

# 4. Требования к реализации (технологический стек)

## 4.1. Бэкенд на Go

1. Использовать **Go** (Golang) для серверной части.  
   - Можно применить любой фреймворк (Fiber, Gin, Echo, net/http и т.д.).  
   - Реализовать **REST API** (или GraphQL, если вам удобнее) для всех операций CRUD по сущностям: Clients, Products, Orders, OrderItems, а также для «подтверждения» заказа.  

2. **Схема БД**:  
   - Хранить сущности в **реляционной** базе (PostgreSQL либо другой).  
   - Таблицы (пример):  
     - `clients (id, name, inn, ...)`  
     - `products (id, name, unit, ...)`  
     - `orders (id, client_id, date, number, total_amount, is_confirmed, ...)`  
     - `order_items (id, order_id, product_id, quantity, price, line_amount, ...)`  
     - `orders_by_client (client_id, orders_sum, ...)`  
   - Связи на уровне Foreign Key (где нужно).  
   - Предусмотреть автоматический пересчёт `line_amount` и `total_amount` (либо в триггерах, либо в коде Go).

3. **Логика подтверждения** (проведения) заказа:  
   - Отдельный endpoint, например `POST /api/orders/{id}/confirm`.  
   - На сервере:  
     - Проверить, что заказ не подтверждён.  
     - Прибавить `total_amount` к `orders_sum` для соответствующего `client_id` в `orders_by_client`. Если записи нет, вставить.  
     - Пометить заказ как «подтверждён» (например, `is_confirmed = true`).  

4. **Валидация** (базовая):  
   - `quantity >= 0`, `price >= 0`.  
   - `name` клиента/товара не пустое.  
   - При подтверждении заказа, если нет позиций, можно выдать ошибку и т.д.

## 4.2. Фронтенд (HTML + JavaScript)

1. **Интерфейс для списка клиентов**  
   - Таблица (ID, name, inn), кнопки «Создать», «Редактировать», «Удалить».  
   - При нажатии «Создать» / «Редактировать» появляется форма (Modal или отдельная страница) для ввода `name`, `inn`.  

2. **Интерфейс для списка товаров**  
   - Аналогично: ID, name, unit.  

3. **Интерфейс для заказов**  
   - Отображение списка заказов с колонками: `id`, `number`, `client.name`, `date`, `total_amount`, `status (confirmed / not confirmed)`.  
   - Кнопки: «Создать», «Изменить», «Подтвердить», «Удалить».  

4. **Форма создания / редактирования заказа**  
   - Поля шапки: выбор клиента из списка (селект), дата, номер.  
   - Таблица (или динамический список) позиций:  
     - Выбор товара (селект), ввод `quantity`, `price`.  
     - `line_amount` рассчитывать сразу на фронте (quantity * price), показывать пользователю.  
   - Поле `total_amount` отображается как сумма всех `line_amount`.  
   - При нажатии «Сохранить» отправлять данные на бэкенд (REST). Бэкенд **пересчитывает** сумму для надёжности.

5. **Подтверждение** заказа  
   - Кнопка «Подтвердить» рядом с заказом: вызов `POST /api/orders/{id}/confirm`.  
   - После успешного подтверждения у заказа статус меняется, и `orders_sum` в «orders_by_client» обновляется.  

> Опционально:  
> - Можно добавить простой **виджет** для просмотра `orders_by_client` — список (client.name, orders_sum).  
> - Или сделать отчёт «Общая сумма заказов по всем клиентам».

---

# 5. Пользовательские сценарии (Business Processes)

1. **Создание нового клиента**  
   - Пользователь заходит в «Clients» → жмёт «Create» → вводит `name`, `inn` → «Save».  

2. **Создание нового товара**  
   - «Products» → «Create» → вводит `name`, `unit` → «Save».  

3. **Формирование заказа**  
   1. Пользователь заходит в «Orders» → «Create».  
   2. Выбирает клиента (из списка), вводит дату, номер (или автоматически).  
   3. Добавляет строки: для каждой строки выбирает товар, количество, цену.  
   4. Приложение (на клиенте) считает `line_amount` (qty * price) и общую `total_amount`.  
   5. Пользователь жмёт «Save» → данные отправляются на сервер, сервер проверяет и пересчитывает (ещё раз) сумму. Записывает заказ.  

4. **Подтверждение (Проведение) заказа**  
   - В списке заказов (или карточке) нажать «Confirm».  
   - Сервер выполняет логику:  
     - Если `is_confirmed` уже true, вернуть ошибку.  
     - Иначе добавляет `total_amount` в `orders_by_client` для `client_id`.  
     - Ставит `is_confirmed = true`.  
   - Интерфейс обновляет статус заказа.

5. **Просмотр сумм заказов по клиентам**  
   - (Если нужно) отдельная страница/таблица: `ClientName` | `OrdersSum`.  
   - Данные берутся из `orders_by_client`.

---

# 6. Нефункциональные требования

1. **Производительность**: достаточно базовых CRUD-операций. Система миниатюрная, высокая нагрузка не предполагается.  
2. **Язык**: Go 1.18+ (или актуальная). JS — любой современный фреймворк (React, Vue, Angular) или даже Vanilla JS, по вашему выбору.  
3. **Хранилище**: PostgreSQL (или другая SQL-БД). Важно иметь возможность развёртывать локально.  
4. **Документация**:  
   - Краткое описание, как запустить.  
   - Пример структуры таблиц (SQL-миграции, если есть).  
   - Пример запросов в Postman или curl для CRUD-операций.

---

# 7. Критерии приёмки

1. **Система запускается локально** (при наличии Go, Node.js или иных инструментов).  
2. **Создание/редактирование/удаление** клиентов и товаров работает штатно (можно увидеть изменения в UI).  
3. **Можно** создать заказ с несколькими позициями, сумма считается автоматически.  
4. **Подтверждение** заказа увеличивает `orders_by_client.orders_sum` на величину `total_amount` заказа.  
5. **После подтверждения** заказ имеет статус «confirmed», не редактируется (или редактируется с пересчётом, если так решено).  
6. **Все API** запросы возвращают корректные коды ответов (2xx, 4xx, 5xx при ошибках).  
7. **Интерфейс** для пользователей (простая веб-страница/SPA) доступен для ручного тестирования.  
8. Код и структура проекта понятны, логику пересчёта сумм легко найти и проверить.

---

# 8. Формат сдачи

1. Исходный код Go-сервиса (Git-репозиторий).  
2. SQL-скрипты или миграции (подключение к PostgreSQL).  
3. Исходный код фронтенда (в том же репозитории или отдельно).  
4. Инструкции по запуску (README).  
   - Как установить зависимости.  
   - Как собрать и запустить Go-приложение.  
   - Как запустить фронтенд (npm install / build, и т.д.).  
   - Как настроить подключение к БД.

---

## Заключение

Данное **ТЗ** описывает **упрощённую** систему учёта заказов:

- **Справочники** «Clients», «Products».  
- **Заказы** (Orders) и **позиции** (OrderItems).  
- **Подтверждение** заказа с автоматической записью итоговой суммы в таблицу `orders_by_client`.

Этого будет достаточно, чтобы **продемонстрировать**:

- Базовые возможности CRUD.  
- Подсчёт и агрегацию значений (суммы).  
- Работа с REST API и элементарным фронтендом.

Система должна быть **минимальной**, но **полнофункциональной** для описанных сценариев.