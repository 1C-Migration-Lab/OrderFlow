Ниже приведено **примерное** (концептуальное) описание **5-го уровня** — **«Code Model / Intermediate Representation (IR)»** — применительно к нашей **мини-конфигурации «Мини Заказы»**. Этот уровень служит **промежуточным** звеном между «низкоуровневым» AST (абстрактным синтаксическим деревом) и «высокоуровневым» (зависимости, архитектура и т.д.).  

Главная идея **Code Model / IR** — собрать **все** сущности кода (модули, процедуры, функции, переменные, вызовы) в **удобную** для анализа структуру:  
- **Уже** не храним детально каждый токен или ветку дерева разбора (как в AST),  
- Но **ещё** не уходим в «бизнес-объекты» (как на архитектурном уровне).  

Таким образом, **Code Model** — это, по сути, **“инвентаризация”** кода, где каждый модуль и каждая процедура представлены в удобном формальном виде, а вызовы/ссылки/зависимости описаны на уровне «кто вызывает кого, что читает/записывает» и т.д.

---

## 1. Общая структура Code Model для «Мини Заказы»

В рамках **мини-конфигурации** у нас есть несколько **метаданных**:  
- **Документ** «ЗаказПокупателя» (и его модули),  
- **Справочники** («Контрагенты», «Номенклатура»),  
- **РегистрНакопления** («ЗаказыПоКонтрагентам»),  
- **Формы** (списки, объекты),  
- (Опционально) **Общие модули** (если есть).

На уровне **Code Model** мы обычно хотим иметь **классы** (или структуры) наподобие:

1. **MetadataObject (Документ/Справочник/Регистр)**  
   - *Имя* (например, «ЗаказПокупателя»)  
   - *Тип* (Document, Catalog, AccumulationRegister и т.д.)  
   - *Список реквизитов / полей* (шапка, табличная часть и их типы)  
   - *Список модулей* (ModuleObject, ModuleManager, ModuleForm…)  

2. **Module** (Модуль объекта, формы, менеджера и т.д.)  
   - *Имя* (например, DocumentObjectModule: «ЗаказПокупателя.Объект»)  
   - *Список процедур и функций* (ProcedureInfo)  
   - *Список локальных переменных / областей) (VarInfo)  
   - (Опционально) ссылки на **импортируемые** модули или объекты

3. **ProcedureInfo / FunctionInfo**  
   - *Имя* (например, «ПриЗаписи»)  
   - *Список параметров* (ParamInfo)  
   - *Тип возвращаемого значения* (если это функция)  
   - *Внутренние операторы* (Statements) — упрощённое дерево (не всё AST, но основная структура)  
   - *Ссылки на внешние вызовы* (CallSiteInfo)

4. **CallSiteInfo** (вызов или обращение к чему-то внешнему)  
   - *Тип* (вызов процедуры, обращение к свойству, движение по регистру и т.д.)  
   - *Имя целевого элемента* (например, `Движения.ЗаказыПоКонтрагентам.Добавить()` или `Справочники.Контрагенты.НайтиПоНаименованию`)  
   - *Аргументы* (список)

5. **Statements** (Операторы) — упрощённый список, без полного parse tree:  
   - IfStatement, ForStatement, AssignmentStatement, и т.д.  
   - В них может быть ссылка на **CallSiteInfo** (вызов процедуры), **VariableReference** (обращение к переменным) и т.д.

Таким образом, **Code Model** содержит **все** объекты, их модули, **все** процедуры/функции и **списки** вызовов внутри них, но без деталей «каждая скобка, каждый token».

---

## 2. Пример содержимого IR для «ЗаказПокупателя»

### 2.1. MetadataObject: Документ «ЗаказПокупателя»

``` 
DocumentInfo {
    Name = "ЗаказПокупателя",
    Type = Document,
    Properties = [
      { Name="Контрагент", Type="CatalogRef.Контрагенты" },
      { Name="СуммаДокумента", Type="Number" },
      { Name="Дата", Type="Date" },
      { Name="Номер", Type="String" }
      // И т.д.
    ],
    TableParts = [
      {
        Name="Товары",
        Fields = [
          { Name="Номенклатура", Type="CatalogRef.Номенклатура" },
          { Name="Количество", Type="Number" },
          { Name="Цена", Type="Number" },
          { Name="СуммаСтроки", Type="Number" }
        ]
      }
    ],
    Modules = [
      ModuleObject { ... },
      ModuleManager { ... },
      // Можно ещё ModuleFormList, ModuleFormObject
    ]
}
```

### 2.2. Модуль объекта «ЗаказПокупателя» (ModuleObject)

``` 
Module {
    Name = "ЗаказПокупателя.Объект",
    Procedures = [
        ProcedureInfo {
            Name = "ПриЗаписи",
            Params = [ Param(name="Отказ"), Param(name="РежимЗаписи") ],
            Statements = [
                // Для примера: Assignment, ForEach, MethodCall
                ForEachStatement {
                    Collection = "Товары",
                    Variable = "СтрокаТЧ",
                    Body = [
                        AssignmentStatement {
                            Left = "СтрокаТЧ.СуммаСтроки",
                            Right = BinaryExpression {
                                Left = "СтрокаТЧ.Количество",
                                Operator = "*",
                                Right = "СтрокаТЧ.Цена"
                            }
                        },
                        // Сумма = Сумма + СтрокаТЧ.СуммаСтроки
                        AssignmentStatement {
                            Left = "Сумма",
                            Right = BinaryExpression {
                                Left = "Сумма",
                                Operator = "+",
                                Right = "СтрокаТЧ.СуммаСтроки"
                            }
                        }
                    ]
                },
                AssignmentStatement {
                    Left = "СуммаДокумента",
                    Right = "Сумма"
                }
            ],
            Calls = [
                // (Если внутри этого кода были вызовы процедур, они бы тут отображались)
            ]
        },
        ProcedureInfo {
            Name = "ПриПроведении",
            Params = [ Param(name="Отказ"), Param(name="РежимПроведения") ],
            Statements = [
                // Движения.ЗаказыПоКонтрагентам.Очистить()
                MethodCallStatement {
                    Target = "Движения.ЗаказыПоКонтрагентам",
                    Method = "Очистить"
                },
                // НоваяСтрока = Движения.ЗаказыПоКонтрагентам.Добавить()
                AssignmentStatement {
                    Left = "НоваяСтрока",
                    Right = MethodCallExpression {
                        Target = "Движения.ЗаказыПоКонтрагентам",
                        Method = "Добавить",
                        Args = []
                    }
                },
                // НоваяСтрока.Контрагент = Контрагент
                AssignmentStatement {
                    Left = "НоваяСтрока.Контрагент",
                    Right = "Контрагент"
                },
                // НоваяСтрока.СуммаЗаказов = СуммаДокумента
                AssignmentStatement {
                    Left = "НоваяСтрока.СуммаЗаказов",
                    Right = "СуммаДокумента"
                }
            ],
            Calls = [
                // Здесь CallSiteInfo: 
                //   - "Движения.ЗаказыПоКонтрагентам.Очистить()"
                //   - "Движения.ЗаказыПоКонтрагентам.Добавить()"
            ]
        }
    ],
    Variables = [
        // Могут быть описаны переменные, если есть "Перем" в модуле
    ]
}
```

*(Обратите внимание: это **очень** упрощённый пример, который иллюстрирует, как могут выглядеть объекты IR. В реальности структура может быть иерархически ещё богаче.)*

---

## 3. Связи и ссылки в Code Model

- **Внутри** одного `Module` (например, «ЗаказПокупателя.Объект») мы можем хранить:  
  - **ProcedureInfo** — список процедур,  
  - **Calls** (или **CallSiteInfo**), где зафиксированы внешние вызовы.  
- **Между** объектами:  
  - `DocumentInfo` хранит ссылки на **свои модули** (ModuleObject, ModuleManager).  
  - Модуль (`Module`) может содержать ссылки на **другие** модули или объекты, если есть явный вызов (`CommonModule.MyProc()`, `Справочники.Контрагенты.ЧтоТоТам`).  

В итоге получается **граф** (или дерево), где **IR** является более «прикладной» структурой: в нём мы видим **методы**, **операторы**, **вызовы** — но уже не видим каждый “keyword” (Процедура, КонецПроцедуры), каждую скобку и т.д. (это остаётся в AST).

---

## 4. Чем Code Model отличается от Dependency Graph?

- На уровне **Dependency Graph** (п.6) мы обычно фиксируем **узлы**: «Документ (ЗаказПокупателя)», «Справочник (Контрагенты)», «Регистр (ЗаказыПоКонтрагентам)» и **рёбра**: «Движения», «Вызов процедуры», «Ссылка на объект», и можем быстро отвечать: «Кто вызывает ПриПроведении?», «Где используется Справочник.Номенклатура?».  
- На уровне **Code Model** (п.5) мы храним **конкретные структуры кода** (Procedures, Statements, Calls) и можем глубже анализировать: **как** внутри процедуры идёт цикл, какие переменные задействованы, какое вычисление происходит, какие параметры передаются в вызов и т.д.  

Грубо говоря, **Code Model** — это более детализированная “программная” модель, а **Dependency Graph** — это “упрощённо-агрегированная” сеть взаимосвязей.

---

## 5. Применение Code Model / IR

1. **Рефакторинг / Навигация в коде**:  
   - Можно легко находить все вызовы процедуры, все места, где присваивается «СуммаДокумента», и т.д.  
2. **Анализ потоков данных**:  
   - Отслеживать, как переменная `Сумма` в процедуре «ПриЗаписи» формируется, проверять, нет ли “неинициализированных” переменных.  
3. **Генерация** документации или привязка к других форматам (например, если мы хотим конвертировать код 1С в Go, IR может стать “промежуточным звеном”).  
4. **Статический анализ**:  
   - Проверка стилей кода, выявление потенциальных ошибок (неиспользуемых переменных, дублирующихся процедур и т.п.).

---

## Резюме

- **Code Model / IR** в контексте «Мини Заказы» включает:  
  1) **Список объектов метаданных** (Document «ЗаказПокупателя», Catalog «Контрагенты», и т.д.),  
  2) **Модули** (ModuleObject, ModuleManager, ModuleForm),  
  3) **Процедуры/Функции** внутри модулей (ProcedureInfo),  
  4) **Внутренние конструкции** (Statements, Calls, Assignments, If/For/While и т.д.).  

- **Цель** — дать **структурированное** представление о коде, чтобы можно было дальше:  
  - Построить **граф вызовов** и зависимостей (п.6).  
  - Связать с **архитектурными** и **бизнес** уровнями (п.7–10).  

- Без **реального** кода можно лишь **приблизительно** описать эту структуру, но даже такое **промежуточное** (абстрактное) понимание полезно для проектирования инструментов анализа/парсинга конфигурации.