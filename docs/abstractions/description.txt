Ниже приведена последовательная схема «уровней абстракции» при анализе конфигурации 1С (или любого другого языка), начиная от текста кода и заканчивая высокоуровневым «бизнес-моделированием». Каждый следующий уровень строится на основе предыдущего.

---

## 1. Текст кода (Source Code)

- **Что это?**  
  Это «сырые» файлы текстов модулей (например, выгруженные из конфигурации 1С в формат `.bsl`, `.os`, `.xml` и т.д.).  
- **Особенности**  
  - Человекочитаемый вид.  
  - Для машинной обработки обычно предварительно приводим к формату, пригодному для парсинга (чистим лишние данные, выделяем отдельные файлы и т. п.).

---

## 2. Лексический уровень (Tokens / Лексический анализ)

- **Что это?**  
  Множество **токенов** — лексических единиц, на которые разбивается исходный текст: ключевые слова, идентификаторы, операторы, числа, строки, и т. п.  
- **Зачем нужно?**  
  - Для упрощения дальнейшего синтаксического анализа.  
  - Лексер «понимает» структуру кода на уровне базовых символов и лексем.  
- **Особенности**  
  - Обычно формируется последовательность объектов вида `(тип_токена, значение, позицияВТексте)`.  
  - Пример: `("Procedure", "Процедура", Строка 10), ("Identifier", "МояПроцедура", Строка 10), ...`.

---

## 3. Синтаксическое дерево (Parse Tree)

- **Что это?**  
  На основе токенов строится **дерево разбора** — максимально детализированное «древовидное» представление структуры кода в соответствии с формальной грамматикой языка.  
- **Зачем нужно?**  
  - Позволяет программе «понять», какие конструкции присутствуют в коде (процедуры, циклы, условные операторы и т. п.).  
  - Это ещё не совсем абстрактное дерево, а более низкоуровневое «привязанное к грамматике».
- **Особенности**  
  - В parse tree обычно все синтаксические элементы (включая скобки, разделители) отображаются узлами.  
  - В случае 1С — это могут быть конструкции типа: `Процедура`, `Если`, `Тогда`, `КонецЕсли`, и т. д.

---

## 4. Абстрактное синтаксическое дерево (AST, Abstract Syntax Tree)

- **Что это?**  
  **AST** — это «очищенная» от избыточных деталей версия дерева разбора, где уже нет «лишних» технических узлов (например, ключевых слов-концов блоков).  
  Оно отражает **семантику** кода: «есть процедура с такими-то параметрами», «внутри неё цикл For…To…», «здесь ветка If…Else…».  
- **Зачем нужно?**  
  - Удобнее для анализа логики.  
  - Легче модифицировать (рефакторинг), строить контроль потока (control flow graph), определять зависимости (кто вызывает что).  
- **Особенности**  
  - В AST обычно узлы могут быть класса `ProcedureDefinition`, `FunctionCall`, `IfStatement` и т.д.  
  - В 1С — можно встретить узлы: `MethodDeclaration (Server)`, `Call (GlobalContext.Справочники.Номенклатура)`, и т. п.

---

## 5. Модель/Представление кода (Code Model / Intermediate Representation)

- **Что это?**  
  Это уровень, на котором мы уже консолидируем все данные о **модулях**, **процедурах**, **функциях**, **переменных**, **объектах** (например, Документах, Справочниках), **вызываемых методах** и т. д.  
  Можно считать это **промежуточным представлением** (IR), в котором каждая сущность 1С имеет свою «программистскую» структуру.  
- **Зачем нужно?**  
  - Для дальнейшего анализа на уровне «модулей», «объектов метаданных», «зависимостей» между процедурами.  
  - Удобно для построения **графа зависимостей** и анализа контрольного потока (CFG).  
- **Особенности**  
  - Здесь мы обычно уже не храним досконально всю грамматику, а оперируем собственными классами-моделями. Например, `МодульОбъекта`, `МодульУправляемойФормы`, `ОбщийМодуль`, `Процедура`, `ВозвращаемоеЗначение` и т. д.  
  - Можем хранить связи: «Из этого метода вызывается такой-то метод другого модуля».

---

## 6. Уровень зависимостей и связей (Dependency Graph / Cross-Reference Model)

- **Что это?**  
  Построение **графа** зависимостей между элементами кода (процедурами, модулями, объектами метаданных), а также связей с внешним окружением (например, вызовы глобального контекста, обращения к регистрам и т. д.).  
- **Зачем нужно?**  
  - Чтобы отвечать на вопросы типа «Где вызывается данная процедура?», «Откуда идёт изменение регистра?», «Какие объекты участвуют в проведении документа?».  
  - Основы для дальнейших «цепочек» и «инструментов визуализации».  
- **Особенности**  
  - Может храниться в реляционной БД или графовой (Neo4j, ArangoDB) для эффективного обхода.  
  - Обычно каждый узел — это «объект/модуль/процедура», каждое ребро — «вызов», «использование» или «наследование».

---

## 7. Уровень «архитектуры» / «функциональной модели»

- **Что это?**  
  На этом уровне мы начинаем смотреть **не только** на код как «процедуры и вызовы», но и на **объекты метаданных** (справочники, документы, регистры, бизнес-процессы 1С) и **их взаимодействие**.  
- **Зачем нужно?**  
  - Чтобы понять «архитектуру» конфигурации: как разложены подсистемы, какие блоки функционала существуют (CRM, Бухгалтерия, Заработная плата и т. п.).  
  - Связать технические объекты (модули, методы) с **функциональным назначением**: «Это подсистема УправлениеТорговлей, модуль расчёта скидок», «Это ПодсистемаЗарплата, модуль расчёта НДФЛ» и т. п.  
- **Особенности**  
  - Иногда можно автоматически “вычислить” подсистемы по структуре конфигурации.  
  - Часто приходится руками создавать «карты» подсистем (например, названия, описания).  
  - В этом слое уже фигурируют **метаданные** 1С: Документы, РегистрСведений, РегистрНакопления, ПланыОбмена, и т. д.

---

## 8. Доменная модель (Domain Model) / «Предметная область»

- **Что это?**  
  Модель, отражающая **предметную область**: какие сущности и процессы (вне 1С, как бизнес-объекты) заложены в конфигурации.  
  Например, «Клиент», «ЗаказПокупателя», «ПоступлениеНаСклад», «ЗарплатныйПроект», «ФондОплатыТруда» и т. п.  
- **Зачем нужно?**  
  - Чтобы люди (аналитики, бизнес-эксперты) могли понять, какие **бизнес-сущности** и **бизнес-процессы** поддерживает конфигурация.  
  - Для системного описания логики в терминах бизнеса (BPMN, UML-диаграммы, ER-модели).  
- **Особенности**  
  - Могут быть «отношения» вроде «Справочник Номенклатура» = бизнес-сущность «Товар», «Документ РеализацияТоваровУслуг» = бизнес-процесс «Продажа» (упрощённо).  
  - Здесь уже высокая степень «семантического» описания: вы знаете не просто «что» вызывается, а **для чего**.

---

## 9. Уровень бизнес-процессов и сценариев (Business Processes / BPM)

- **Что это?**  
  Модель, которая описывает, **как** именно работает бизнес в рамках конфигурации: последовательность действий пользователя, автоматические расчёты, обмен данными, интеграции, регламенты.  
- **Зачем нужно?**  
  - Отвечать на вопросы: «Какие операции по продажам автоматизированы?», «Как проходит согласование счётов?», «Какие шаги в цепочке от Заказа до Реализации?».  
  - Обобщённое понимание, «зачем» нужен каждый документ, справочник, регистр.  
- **Особенности**  
  - Может фиксироваться в виде BPMN-диаграмм, технологических карт, схем взаимодействия подсистем.  
  - Частично это можно извлечь из конфигурации автоматически (особенно если в конфигурации есть объекты «Бизнес-процесс»), но чаще требуется ручная работа аналитика, т. к. «чтение мыслей» конфигурации не всегда возможно.

---

## 10. Уровень «бизнес-модели» (Business Model)

- **Что это?**  
  Конечная, наиболее абстрактная надстройка, где **все** технические детали скрыты, а проектировщики и менеджмент видят систему как набор **бизнес-функций**: «Продажи», «Закупки», «Складской учёт», «Зарплата и Кадры», «Бухучёт», «Отчётность» и т. п.  
- **Зачем нужно?**  
  - Для общения с бизнес-стейкхолдерами: руководство, пользователи, методологи.  
  - Чтобы принимать решения о развитии системы, оптимизации процессов, оценке влияния изменений.  
- **Особенности**  
  - Этот слой часто включает **финансовые**, **коммерческие** или **организационные** аспекты (например, KPI, SLA, ROI от автоматизации).  
  - Здесь технические детали 1С проявляются лишь как «поддерживающие механизмы».

---

### Суммируем в виде «пирамиды» снизу вверх

1. **Source Code** (текст кода)  
2. **Lexical Analysis** (Токены)  
3. **Parse Tree** (Дерево разбора)  
4. **AST** (Абстрактное синтаксическое дерево)  
5. **Code Model / IR** (Промежуточное представление кода и объектов)  
6. **Dependency Graph / Cross-Reference** (Граф вызовов, ссылок, зависимостей)  
7. **Архитектурный / Функциональный уровень** (Подсистемы, модули, объекты метаданных)  
8. **Domain Model** (Бизнес-сущности, предметная область)  
9. **Business Processes** (BPM, сценарии, регламенты)  
10. **Business Model** (Верхнеуровневая бизнес-схема, функции, цели, KPI)

---

## Как это используется в вашем «анализаторе 1С»?

1. **Парсер** строит **Parse Tree** и дальше **AST** из текстов модулей.  
2. На основе AST формируете **Code Model**, где есть модули, процедуры, объекты конфигурации (справочники, документы).  
3. Из **Code Model** можно извлечь **Dependency Graph** (кто кого вызывает, какие регистры читаются/пишутся).  
4. Анализируя **метаданные** (подсистемы, иерархии), вы собираете «архитектурный слой»: какие подсистемы, функции и т. д.  
5. Для **доменной модели** (предметной области) и **бизнес-процессов** вы добавляете семантические описания (теги, документирование, бизнес-термины).  
6. На самом верху формируется единая **бизнес-модель**, доступная для «непрограммистов».  

Так достигается полная «сквозная» трассировка от бизнес-процесса в верхнем слое до конкретного модуля и строки кода, который этот процесс обеспечивает.